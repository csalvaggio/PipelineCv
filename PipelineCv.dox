/**
 * @file PipelineCv.dox
 * @brief Main documentation page and group definitions for pcv pipe adapters.
 */

/**
 * @mainpage PipelineCv - A pipeline OpenCV adapter library
 *
 * @section intro_sec Overview
 * PipelineCv is a tiny, header-only toolkit for composing OpenCV cv::Mat transforms using a functional pipe style. Chain operations together for readable, declarative image processing pipelines.
 *
 * @code{.cpp}
 * cv::Mat img = cv::imread("in.png", cv::IMREAD_COLOR);
 *  
 * cv::Mat spectrum = img
 *   | pcv::to_float()         // convert to CV_32F in [0,1]
 *   | pcv::to_gray()          // grayscale
 *   | pcv::pad_to_even()      // FFT-friendly sizes
 *   | pcv::dft()              // two-channel complex DFT
 *   | pcv::fft_shift()        // center DC
 *   | pcv::power_spectrum();  // |F|^2 (log)
 * @endcode
 *
 * @section requirements Requirements
 * - C++ compiler that supports C++20 dialect/ISO standard
 * - OpenCV (v4.3.0 or higher) (core/imgproc)
 *
 * @section installation Installation
 * PipelineCv is header-only. Simply include it in your project (for example):
 *
 * @code{.cpp}
 * #include "pcv/PipelineCv.h"
 * @endcode
 *
 * @section notes_sec Notes
 * - The pipe operator accepts any callable with signature cv::Mat(const cv::Mat&)
 * - Complex operations require 2-channel inputs (CV_32FC2 or CV_64FC2)
 * - For FFT visualization, use even dimensions (pcv::pad_to_even()) and center DC with pcv::fft_shift()
 *
 * @section error_sec Error Handling
 * Most adapters use `CV_Assert` for precondition checks (e.g., complex inputs must have 2 channels)
 *
 * @section perf_sec Performance Tips
 * - Prefer `CV_32F` for frequency operations; convert once, process, then convert back
 * - Use pcv::pad_to_even() before pcv::dft() for clean quadrant swaps with pcv::fft_shift()
 * - Compose operations to minimize intermediate copies when practical
 *
 * @section examples_sec Quick Examples
 *
 * @subsection ex_normalize Normalize and Clamp
 * @code{.cpp}
 * cv::Mat out = img
 *   | pcv::to_float()
 *   | pcv::normalize(0.0, 1.0);
 * @endcode
 *
 * @subsection ex_fourier Fourier Transform & Magnitude
 * @code{.cpp}
 * cv::Mat mag = img
 *   | pcv::to_float()
 *   | pcv::to_gray()
 *   | pcv::pad_to_even()
 *   | pcv::to_complex()
 *   | pcv::dft()
 *   | pcv::magnitude();
 * @endcode
 *
 * @subsection ex_blend Image Blend
 * @code{.cpp}
 * cv::Mat blended = img
 *   | pcv::add(other, alpha=1.0, beta=0.7, gamma=0.0)
 *   | pcv::clamp(0, 255);
 * @endcode
 *
 * @section contact_sec Contact
 * @par Author
 * Carl Salvaggio, Ph.D.
 *
 * @par E-mail
 * carl.salvaggio@rit.edu
 *
 * @par Organization
 * Chester F. Carlson Center for Imaging Science@n
 * Rochester Institute of Technology@n
 * Rochester, New York, 14623@n
 * United States
 */

// ============================================================================
// Group Definitions
// ============================================================================

/** 
 * @defgroup type_and_channel_adapters Type and Channel Adapters
 * @brief Functions related to type conversions and channel extraction/combination.
 */

/** 
 * @defgroup scalar_value_transforms Scalar/Value Transforms
 * @brief Functions for scalar/value transformations and per-pixel value operations.
 */

/** 
 * @defgroup elementwise_operations Element-wise Arithmetic Operations
 * @brief Functions for performing element-wise mathematical operations between two cv::Mats.
 */

/** 
 * @defgroup complex_domain_operations Complex-Domain Operations
 * @brief Functions for performing element-wise complex-domain operations.
 */

/** 
 * @defgroup fourier_frequency_domain_utilities Fourier/Frequency-Domain Utilities
 * @brief Fourier and frequency domain utility functions.
 */

/** 
 * @defgroup spatial_utilities Spatial Utilities
 * @brief Spatial utilities for geometrically modifying cv::Mats.
 */
